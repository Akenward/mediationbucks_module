<?php
/**
 * @file
 * Sets up and handles changes to the availability form.
 */
 
 module_load_include('module', 'availability_week');
  
  /**
 * Implements hook_entity_info().
 */
function availability_entity_info(){
  // Set up the availablity and update entities
  $availability_info = array(
    'availability' => array(
      'label' => t('Availability Record'),
      'plural label' => t('Availability Records'),
      'description' => t('An entity type used for recording mediator availability.'),
      'entity class' => 'AvailabilityClass',
      'controller class' => 'EntityAPIController',
      'base table' => 'availability',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'vid',
      ),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'bundles' => array(
	    'availability'=> array(
          'label' => 'Availability',
	    ),
	  ),
      
      'module' => 'availability',
      'views controller class' => 'EntityDefaultViewsController',
      'static cache' => TRUE,
      'view modes' => array(
        'full' => array(
          'label' => t('Full Availability'),
          'custom settings' =>  FALSE,
        ),
      ),
    ),
  
    'updates' => array(
      'label' => t('Update Record'),
      'plural label' => t('Update Records'),
      'description' => t('An entity type used for reporting on mediator update status.'),
      'entity class' => 'UpdatesClass',
      'controller class' => 'EntityAPIController',
      'base table' => 'updates',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'sid',
      ),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'bundles' => array(
	    'updates'=> array(
          'label' => 'Updates',
	    ),
	  ),
      
      'module' => 'availability',
      'views controller class' => 'EntityDefaultViewsController',
      'static cache' => TRUE,
      'view modes' => array(
        'full' => array(
          'label' => t('Full Availability'),
          'custom settings' =>  FALSE,
        ),
      ),
    ),
  );
  return $availability_info;
}

/**
 * Class for availability entity.
 */
class AvailabilityClass extends Entity {

  public function __construct(array $values = array(), $entityType = NULL) {
    parent::__construct($values, 'availability');
  }
}

/**
 * Class for updates entity.
 */
class UpdatesClass extends Entity {

  public function __construct(array $values = array(), $entityType = NULL) {
    parent::__construct($values, 'updates');
  }
}

/**
 * Custom Views Controller class to allow a change of field handler.
 */
class AvailabilityViewsController extends EntityDefaultViewsController {
  /*
    * Set the field handler of the start_date property to the data handler.
	* As start_date is an integer using UNIX timestamp format, the default handler
	* would be numeric. 
    */
  public function views_data() {
    $data = parent::views_data();
    $data['availability']['start_date']['field']['handler'] = 'views_handler_field_date';
	$data['updates']['start_date']['field']['handler'] = 'views_handler_field_date';
	$data['availability']['field_availability_week']['field']['handler'] = 'views_handler_field_field';
    return $data;
  }
}

/**
 *  Implements hook_views_api to make Views api functions available
 */
function availability_views_api() {
  return array ('api' => 3);
}

/*function availability_views_post_render(&$view, &$output, &$cache){
  if ($view->name == 'availability_test') {
  	$periods = availability_periods_factory();
	$context = current_context_factory();
	$markup = '';
	$week = NULL;
  	$aggregate = array();
	foreach ($view->result as $seq => $record) {
	  $week = $record->availability_start_date;
	  if ($context->inRange($week)){
	    $week_string = $view->style_plugin->row_tokens[$seq]['[start_date]'];
	    $aggregate[$week]['week_string'] = $week_string;
	    foreach ($periods->availabilityDays() as $m_d => $m_days) {
	      foreach ($periods->availabilityTimes() as $m_t => $m_times) {
	        foreach ($record->field_field_availability_week as $delta => $week_part)
	  	    if ($week_part['raw'][$m_t.'_'.$m_d] > 1) {
	  	  	  if (isset($aggregate[$week][$m_t.'_'.$m_d])){
	  	  	    $aggregate[$week][$m_t.'_'.$m_d] ++;
	  	  	  }
              else {
	            $aggregate[$week][$m_t.'_'.$m_d] = 1;
              }
	  	    }
	  	  }
	    }
	  }
	}
	$markup .= '<div class="view-content">';
    foreach($aggregate as $week => $row_data) {
      $markup .= '<table class="views-table cols-15"><caption>' . $aggregate[$week]['week_string'] . '</caption><thead><tr>';
	  foreach ($periods->availabilityDays() as $m_d => $m_days) {
	    foreach ($periods->availabilityTimes() as $m_t => $m_times) {
	      $short_time = $periods->availabilityTimes('lo')[$m_t];
		  $short_day = $periods->availabilityDays('lo')[$m_d];
		  $day_number = $periods->availabilityDateCalc($week, $m_d);
	      $markup .= '<th class="views-field views-field-'. $m_d . '-' . $m_t . '" scope="col">' . $short_day . '<br/> ' . $day_number . '<br/>' . $short_time .  '</th>';
		}
	  }
	  $markup .= '</tr></thead><tbody><tr>';
      foreach ($periods->availabilityDays() as $m_d => $m_days) {
	    foreach ($periods->availabilityTimes() as $m_t => $m_times) {
	      $markup .= '<td class="views-field views-field-'. $m_d . '-' . $m_t . '">' . $aggregate[$week][$m_t.'_'.$m_d] . '</td>';
		}
	  }
	  $markup .= '</tr></tbody></table>';   
    }
	$markup .= '</div>';
	$output = $markup;
  }	
}*/

/**
 * Implements hook_views_aggregation_functions_info.
 *
 * @return array
 *   aggregation display names indexed by associated function name.
 */
/*function availability_views_aggregation_functions_info() {
  $functions = array(
    'availability_week_summary' => array(
      'group' => t('Week summary'),
      'column' => NULL, // use NULL if not applicable

      // If your function operates on a numeric field, but the result is no
      // longer a (single) number, for example when enumerating values, then the
      // original renderer is not appropriate. In that case set this to FALSE.
      'is_renderable' => TRUE, // this is the default
    ),
  );
  return $functions;
}

function availability_week_summary($groups, $field_handler) {
  
  $values = array();
  $periods = availability_periods_factory();
  foreach ($groups as $group => $rows){
  	$values[$group]['notes'] = '';
  	foreach ($periods->availabilityTimes() as $m_t => $m_time) {
  	  foreach ($periods->availabilityDays() as $m_d => $m_day) {
  	  	$values[$group][$m_t.'_'.$m_d] = 0;
  	  }
  	}
	foreach ($rows as $num => $row) {
	  foreach ($periods->availabilityTimes() as $m_t => $m_time) {
  	    foreach ($periods->availabilityDays() as $m_d => $m_day) {
		  if ($row->field_field_availability_week[0]['raw'][$m_t.'_'.$m_d] > 1) {
		  	$values[$group][$m_t.'_'.$m_d] ++ ;
		  }
  	    }
  	  }
	}
  }
  return $values;
}*/

/**
 * Implements hook_menu().
 */
function availability_menu(){
	
  $items = array();
  
  // Registers a path with menu item to the configuration settings for Availability
  $items['admin/config/content/availability'] = array(
    'title' => t('Availability settings'),
    'description' => t('Control the data displayed'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('availability_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/availability.admin.inc',
    'type' => MENU_NORMAL_ITEM, // optional
  );
 
  // Registers a path with menu item to call the availability form
  $items['availability'] = array(
    'description' => 'A form to record availability for mediation work.',
    'title' => 'My availability',
    'page callback' => 'drupal_get_form', //this is the function that will be called when the page is accessed.  for a form, use drupal_get_form
    'page arguments' => array('availability_form'), //the name of the form here
    'access arguments' => array('record availability'),
  );

  // Registers a path with menu item for the Views availability reports
  $items['availability-reports'] = array(
    'title' => t('Availability reports'),
    'description' => t('Control the data displayed'),
    'page callback' => 'views_page', //this is the function that will be called when the page is accessed.  for a form, use drupal_get_form
    'page arguments' => array('mediator_availability', 'page'), //the name of the form here
    'access arguments' => array('view availability'),
  );
  
  return $items;
}

/**
 * Implements hook_menu_link_alter
 */
/*function availability_menu_link_alter(&$item) {
  switch ($item['link_title']) {
    case 'Mediator availability':
	  $item['plid'] = current(_get_the_mlids('availability-reports'));
	break;
	case 'Availability by mediator':
	  $item['plid'] = current(_get_the_mlids('availability-reports'));
	break;
	case 'Missing updates':
	  $item['plid'] = current(_get_the_mlids('availability-reports'));
	break;
	case 'Updates provided':
	  $item['plid'] = current(_get_the_mlids('availability-reports'));
	break;
	case 'Meeting':
	  $item['type'] = MENU_SUGGESTED_ITEM;
	break;
	case 'Case list':
	  $item['type'] = MENU_SUGGESTED_ITEM;
	break;
	
  default:
	break;
  }
}*/

/**
 * Helper function to get the mlid(s) pointing to a given path
 * @path: the path
 */
function _get_the_mlids($path) {
  $mlid = array();
  $menu_info = db_select('menu_links' , 'ml')
    ->condition('ml.link_path' , $path)
    ->fields('ml', array('mlid', 'plid'))
    ->execute()
    ->fetchAll();

  foreach($menu_info as $key => $value) {
    $mlid[] = $menu_info[$key]->mlid;
  }
  return $mlid;
}

/**
 * Implements hook_info.
 */ 
function availability_info() {
  return ('Welcome to the administration page for your availability records');
}
 
/**
 * Implements hook_permission().
 */
function availability_permission(){
  return array(
    'administer availability' =>  array(
      'title' => t('Administer availability'),
      'restrict access' => TRUE,
    ),
    'view availability' => array(
      'title' => t('View availability records'),
    ),
    'record availability' => array(
      'title' => t('Record own availability'),
    ),
  );
}

/**
 * Implements hook_form().
 */
function availability_form($form, &$form_state) {
  // A context object is created and held in $form_state until the form is cancelled.
  // This keeps track of the mediator and week we're currently dealing with.
  // By storing the object in the $form_state array we can just carry on where we left
  // off after the form is rebuilt.
  if (!isset($form_state['availability_context'])) {
    $context = current_context_factory();
    $form_state['availability_context'] = $context;
  }
  
  // Get the availability record for userid/start date 
  // The storage class does all the database handling for availability records
  // A storage object is instantiated with $context so it knows which record(s)
  // to load or save.
  $storage = availability_storage_factory($form_state['availability_context']);
  $entity = $storage->availabilityRetrieveEntity();
  $form_state['availability_current_entity'] = $entity;
  $items = field_get_items('availability', $entity, 'field_availability_week');
     
  if(user_access('view availability')) {
	// auto-complete text box for office team to select a mediator
    // to update records on his/her behalf.  Mediator saved in the context variable. 
    $form['mediator'] = array(
      '#type' => 'textfield',
      '#title' => t('Mediator'),
      //'#prefix' => '<div id="availability_data_wrapper">',
      '#size' => 30,
      '#maxlength' => 60,
      '#autocomplete_path' => 'user/autocomplete',
      '#default_value' => $form_state['availability_context']->availabilityCurrentMediator()->name,
      '#weight' => '0',
    );
	// Submit button (using default callback function hook_form_submit)
    $form['select_mediator'] = array(
      '#type' => 'submit',
      '#value' => t('select mediator'),
      '#executes_submit_callback' => TRUE,
      '#validate' => array('validate_new_mediator'),
      '#submit' => array('select_new_mediator'),
      '#weight' => '2',
    );
  }
  
  // Prepare and display the mediator and period information
  $format = 'l jS F Y';
  $date_confirm = 'Availability for ' . $form_state['availability_context']->availabilityCurrentMediator()->name . 
    ' week commencing ' . date_format_date($form_state['availability_context']->availabilityCurrentMonday(), 'custom', $format);
  
  $form['week_commencing'] = array(
    '#markup' => '<h3>' . $date_confirm . '</h3>',
    '#weight' => '4',
  );
  
  // Button to move to the previous week, calling function 'week_back'
  $form['earlier_monday'] = array(
    '#type' => 'submit',
    '#value' => t('previous week'),
    '#executes_submit_callback' => TRUE,
    '#submit' => array('week_back'),
    '#weight' => '6',
  );
  
  // Button to move to the next week, calling function 'week_forward
  $form['later_monday'] = array(
    '#type' => 'submit',
    '#value' => t('next week'),
    '#executes_submit_callback' => TRUE,
    '#submit' => array('week_forward'),
    '#weight' => '8',
  );
  
  
  // Insert availability data grid and notes as a field_availability_week widget
  if (!isset($form['#parents'])) {
  	$form['#parents'] = array();
  }
  $instance = field_info_instance('availability', 'field_availability_week', 'availability');
  $field = field_info_field_by_id($instance['field_id']);
  $form_element = field_default_form('availability', $entity, $field, $instance, 'und', $items, $form, $form_state);
  $form_element['field_availability_week']['#weight'] = '10';
  $form = array_merge_recursive($form_element, $form);
  
  // MeetingCommitments class handles meeting information. We use a MeetingCommitments object
  // to retrieve the meetings scheduled for the current mediator during the current week.
  $meeting_commitments = new MeetingCommitments(
    $form_state['availability_context']->availabilityCurrentMediator()->uid,
    $form_state['availability_context']->availabilityCurrentMonday()->format('U'),
    NULL
  );
  $meeting_list = $meeting_commitments->listCommitments();
  $meeting_string = '';
  if (strlen($meeting_list) > 0) {
    $meeting_string = '<h3>' . t('Meeting information:') . '</h3> ' .
	  $meeting_list ;
  }
  
  // The meeting information is placed as a markup element in a container created as part of the
  // field_availability_week widget	
  $form['field_availability_week']['und'][0]['meetings_container']['meetings_markup'] = array(
    '#type' => 'markup',
    '#markup' => $meeting_string,
  );
   
  // Checkbox control for repeating weeks
  $form['repeat_wrapper'] = array(
     '#type' => 'container',
	 '#attributes' => array(
       'class' => array('repeat-group', 'text-vertical-1'),
	 ),
	 '#weight' => '12',
	 'repeat_week' => array(
       '#title' => 'Repeat for another ',
       '#type' => 'checkbox',
       '#default_value' => FALSE,
     ),
   );
   
   // Spinner control for number of repeating weeks
   $form['repeat_number_wrapper'] = array(
     '#type' => 'container',
     '#weight' => '14',
	 '#attributes' => array(
       'class' => array('repeat-group'),
	 ),
	 'number_weeks' => array(
       '#title' => '',
       '#type' => 'textfield',
       '#default_value' => 0,
       '#size' => 5,
       '#attributes' => array('id' => 'edit-number-weeks'),
       '#attached' => array(
         'library' => array(
           array('system', 'ui.widget'),
         ),
         'js' => array(
           drupal_get_path('module', 'availability') . '/scripts/spinner.js',
           drupal_get_path('module', 'availability') . '/scripts/my_availability.js',
         ),
       ),
     ),
   );
   
  // Text to help make repeating weeks controls make sense
   $form['repeat_label_wrapper'] = array(
     '#type' => 'container',
     '#weight' => '16',
	 '#attributes' => array(
       'class' => array('repeat-group', 'text-vertical-2'),
	 ),
	 'number_label' => array(
       '#type' => 'markup',
       '#markup' => '<p> weeks </p>',
     ),
   );
   
  // Submit button calling default callback function availability_form_submit
  $form['submit_button'] = array(
    '#type' => 'submit',
    '#value' => t('Save the week'),
    '#prefix' => '<div class="availability-submit">',
    '#weight' => '18',
  );
  
  // Cancel button, calling function 'form_cancel'
  $form['cancel_button'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#suffix' => '</div>',
    '#submit' => array('form_cancel'),
    '#weight' => '20',
  );
  return $form;
}

/**
 * Implements hook_form_validate().
 */
function availability_form_validate($form, &$form_state) {
  
}

/**
 * Implements hook_form_submit().
 */
function availability_form_submit($form, &$form_state) {
  //$availability = $form_state['values']['field_availability_week'];
  //$monday = $form_state['availability_context']->availabilityCurrentMonday();
  // Instantiate a storage object with the current context object 
  $storage = availability_storage_factory($form_state['availability_context']);
    if ($form_state['values']['repeat_week'] 
    && isset($form_state['values']['number_weeks']) 
    && $form_state['values']['number_weeks'] > 0) {
  	// Request to save same availability pattern for the current week plus
  	// additional weeks
  	$repeat_weeks = $form_state['values']['number_weeks'];
	$report = $storage->availabilitySaveEntity($form, $form_state, $repeat_weeks);
  }
  else {
  	// Request to save availability pattern just for the current week
  	$repeat_weeks = 0;
    $report = $storage->availabilitySaveEntity($form, $form_state);
  }
  
  $monday = $form_state['availability_context']->availabilityCurrentMonday();
  if (count(array_filter($report)) == $repeat_weeks + 1 ) {
  	// If all requested weeks saved successfully, confirm to user.
  	$msg = 'Thank you. ' . count($report) . ((count($report)>1)?' weeks':' week') .
  	  ' successfully saved commencing ' . $monday->format('l jS F');
  	drupal_set_message($msg , $type = 'status');
  }
  else {
  	// If any failed give the user a report
  	$msg = t('We had a problem saving your record(s). ' .  count($report).
  	 ((count(array_filter($report))>1)?' weeks':' week') . 'were saved out of ' . $repeat_weeks + 1 . 
  	 ' requested commencing ' . $monday->format('l jS F'). '.  Please contact the office.');
  	drupal_set_message($msg , $type = 'error');
  }
  unset($form_state['input']['field_availability_week']);
  unset($form_state['input']['repeat_week']);
  unset($form_state['input']['number_weeks']);
  $form_state['rebuild'] = TRUE;
}

/**
 * Validation handler for new mediator name
 *
 */ 
function validate_new_mediator($form, &$form_state){
  if (!user_load_by_name($form_state['values']['mediator']) || !is_object(user_load_by_name($form_state['values']['mediator']))) {
	form_set_error('mediator', 'Enter a valid user name.');
  }
  else {
    if (!in_array('mediator', user_load_by_name($form_state['values']['mediator'])->roles)) {
	  form_set_error('mediator', "This user is not a mediator.");
	}
  }
}

/**
 * Submit handler for new mediator name
 * 
 */ 
function select_new_mediator($form, &$form_state) {
  $mediator = user_load_by_name($form_state['values']['mediator']);
  $form_state['availability_context']->setCurrentMediator($mediator);
  $form_state['rebuild'] = TRUE;
  unset($form_state['input']['field_availability_week']);
  unset($form_state['input']['repeat_week']);
  unset($form_state['input']['number_weeks']);
}


/**
 * Button handler to implement moving to next week.
 * provided we haven't gone further ahead than the upper limit
 */ 
function week_forward($form, &$form_state) {
  $result = $form_state['availability_context']->nextMonday();
  if (!$result) {
	drupal_set_message(t('This is as far ahead as we record.') , $type = 'status');
  } 
  $form_state['rebuild'] = TRUE;
  unset($form_state['input']['field_availability_week']);
  unset($form_state['input']['repeat_week']);
  unset($form_state['input']['number_weeks']);
}

/**
 * Button handler to implement moving to previous week.
 * provided we haven't gone further back than the lower limit
 */
function week_back($form, &$form_state) {
  $result = $form_state['availability_context']->previousMonday();
  if (!$result) {
	drupal_set_message(t('This is the earliest you can update.') , $type = 'status');
  } 
  $form_state['rebuild'] = TRUE;
  unset($form_state['input']['field_availability_week']);
  unset($form_state['input']['repeat_week']);
  unset($form_state['input']['number_weeks']);
}

function form_cancel($form, &$form_state){
	unset ($form_state['availability_context']);
	$form_state['rebuild'] = FALSE;
	$form_state['redirect'] = 'node';
}



/**
 * Implements hook_block_info to introduce the block 
 */ 
function availability_block_info() {
  $blocks['mediators'] = array (
    'info' => t('Available mediators'),
    'cache' => DRUPAL_CACHE_PER_ROLE,
    'weight' => 20,
  );
  return $blocks;
}

/**
 * Implements hook_block_view to set up the list of mediators available at a given period on a given day 
 */ 
/*function availability_block_view($delta = '') {
  switch ($delta) {
    case 'mediators':
	module_load_include('module', 'entity');
    module_load_include('inc', 'availability', 'includes/meetings');
    module_load_include('inc', 'availability', 'includes/availability');
    $path = drupal_get_path('module', 'availability');
    drupal_add_js($path . '/scripts/table_style.js');
    
    // Rebuild scripts 
    $scripts = drupal_get_js();
    $vars['scripts'] = $scripts;
	// Set up arrays for handling days of the week and periods of the day
    $periods = availability_periods_factory();
	$meetings = new MeetingCommitments();
    $block = array();
	
	// Set up array to hold mediator data for the selected day
	$link_array = array();
	
	// query the database for all availability records.  
	$query = new EntityFieldQuery;
	  
    $dvids = $query
      ->entityCondition('entity_type', 'availability')
      ->execute();
	
	// If we find any, load them
    if (sizeof($dvids) >= 1 && sizeof($dvids['availability']) >= 1) {
	  $results = entity_load('availability', array_keys($dvids['availability']));*/
	
	  /**
	  * For each availability record found query the user table for the mediator name corresponding to the uid
	  * in the availability record
	  */	
	  /*foreach ($results as $record) { 
	    $query = new EntityFieldQuery;
	    $dvids = $query
	      ->entityCondition('entity_type', 'user')
          ->propertyCondition('uid', $record->uid)
          ->execute();
		$this_date = strftime("%Y-%m-%d", $record->start_date);*/
	    /**
	    * For each availability record found query the user table for the mediator name corresponding to the uid
	    * in the availability record and add an element to $link_array consisting of an associative array keyed on uid
		* This array includes positive availability data 
	    */	
	    /*if (sizeof($dvids) >= 1 && sizeof($dvids['user']) >= 1) {
	      $this_user = entity_load('user', array_keys($dvids['user']));
		  if (in_array('mediator', $this_user[$record->uid]->roles)) {
	        $link_array[$record->uid]['name'] = $this_user[$record->uid]->name;
	        $link_array[$record->uid][$this_date]['notes'] = $record->notes;
		    foreach ($periods -> availabilityTimes() as $m_t => $m_time) {
		  	  foreach ($periods -> availabilityDays() as $m_d => $m_day) {
		  	    $field_name = $m_d . '_' . $m_t;
		  	    if ($record->$field_name != '0' ) {
		  	  	  $link_array[$record->uid][$this_date]['available'][$field_name] = $record->$field_name;
				}
		  	  }
		  	}
		  }
		}
	  }
	}
	$date_limits = availability_week_limits();
	$start_date = $date_limits['lower'];
	while ($start_date <= $date_limits['upper']) {
	  foreach ($periods -> availabilityTimes() as $m_t => $m_time) {
        foreach ($periods -> availabilityDays() as $m_d => $m_day) {
      	  $mediator_list = $meetings->checkPeriod($start_date, $m_d, $m_t, true);
		  foreach ($mediator_list as $mediator_meeting) {
		  	$mediator_uid = $mediator_meeting['uid'];
			$field_name = $m_d . '_' . $m_t;
			$link_array[$mediator_uid]['name'] = $mediator_meeting['name'];
			$link_array[$mediator_uid][$start_date->format('Y-m-d')]['meeting'][$field_name][] = array(
			  'title' => check_plain($mediator_meeting['title']),
			  'date' => $mediator_meeting['date'],
			  'time' => $mediator_meeting['time'],
			);
		  }
		}
      }
	  $start_date->modify('+1 week');
    }
	// check access permissions before populating the block
	if (user_access('view availability')) {
      
	  // Get the meeting highlight array for the mediator_availability view table and pass it, with $link_array to Drupal settings
	  $meetings_array = setup_main_table_meetings();
	  drupal_add_js(array('availability' => array('mediators' => $link_array, 'meetings' => $meetings_array)), 'setting');
	  
	  $block['content'] = theme('mediator_list', array('subject' => t('Available Mediators')));
	  
	  return $block;
	}
  }
}*/

/**
 *  Implements hook_theme to provide a presentation layer for the mediator list block
 */
/*function availability_theme() {
  return array(
    'mediator_list' => array(
      'template' => 'mediator_list',
      'variables' => array('subject' => NULL),
    ),
  );
}*/

/**
 *  Implements hook_cron to carry out scheduled tasks.  Specifically maintaining the table that tracks mediator
 *  updates and deleting availability records older than the "delete week" criterion.  Also sending out emails
 *  to all mediators prompting them to update their availability for the week after next if it's the designated
 *  day of the week and the job hasn't been done in the last three days.  If all emails are sent successfully by
 *  the drupal_mail function then availability_last_email is updated in the array of persistent variables. 
 *   
 */
/*function availability_cron() {
  module_load_include('inc', 'availability', 'includes/availability');
  module_load_include('module', 'entity');
  $date_limits = availability_week_limits();
  $availability_settings= variable_get("availability_settings", array());
  
  $now = new DateObject();
  
  // set up arrays for weekday and period of day values
  $periods = availability_periods_factory();
  
  $disposal = array();
 
  //load all users and filter to leave only mediators
  $query = new EntityFieldQuery;
  $dvids = $query
  ->entityCondition('entity_type', 'user')
  ->propertyCondition('status', 1)
  ->execute();
  if (sizeof($dvids) >= 1 && sizeof($dvids['user']) >= 1) {
	$results = entity_load('user', array_keys($dvids['user']));
    $mediators = array_filter($results, "find_mediator");
  }
  
  //Delete all the existing update records
  $disposal = array();
  $results = entity_load('updates');
  if (sizeof($results) > 0) {
    foreach ($results as $update) {
  	  $disposal[] = $update->sid;
	}
	entity_delete_multiple('updates', $disposal);
  }
  
  // Set up update records for all mediators over the date range with 0 report status
  // First find the start Monday ...
  $monday = clone($date_limits['lower']);
  // ... then loop through each week till we reach the upper end of the date range
  // creating and update record for each mediator for each week in the active date range
  // whether or not availability reports have been submitted with initial report status 0.  
  // Later on those covered by a submitted availability report are updated to status 1.   
  while ($monday <= $date_limits['upper']) {
  	foreach ($mediators as $mediator) {
	  $values = array(
        'uid' => $mediator->uid,
        'mediator_name' => $mediator->name,
        'start_date' => $monday->getTimestamp(),
        'report_status' => 0,
      );
      $result = entity_create('updates', $values);
      $result->is_new = TRUE;
	  $report = entity_save('updates', $result);
    }
	$monday->modify('+1 week');
  }
  $disposal = array();
  $updates = entity_load('updates');
  $results = entity_load('availability');
  $update_ticks = array();
  // make a list of availability records for weeks earlier than the delete date 
  foreach ($results as $avail) {
	if ($avail->start_date <=  $date_limits['delete']->getTimeStamp()) {
		$disposal[] = $avail->vid;
	}
	// find the update record corresponding to the availability record and update report status to 1
    foreach ($updates as $update) {
      if (($update->uid == $avail->uid) && ($update->start_date == $avail->start_date)) {
      	$update->report_status = 1;
		$report = entity_save('updates', $update);
      }
    }
  }
  // action the delete list of availability records 
  if (sizeof($disposal) > 0) {
    entity_delete_multiple('availability', $disposal);
  }
  
  // check the date and, if it's the due day for a prompt and the last prompt (availability_last_email) was more than three days ago
  // send out the prompt emails to all users with role 'mediator'.  If all emails go out OK then reset
  // the availability_last_email date to today and save with persistent variables. 
  $date_today = new DateObject();
  if (strtolower(date_day_of_week_name($date_today, FALSE)) == $availability_settings['availability_prompt_day']  && $availability_settings['availability_weekly_reminder']) {
  	$diff = NULL;
  	if (isset($availability_settings['availability_last_email'])) {
  	  $email_date = new DateObject($availability_settings['availability_last_email']);
	  $diff = $date_today->difference($email_date, 'days');
  	}
	if (is_null($diff) || $diff > 3) {
	  $query = new EntityFieldQuery;
	  $dvids = $query
	    ->entityCondition('entity_type', 'user')
        ->execute();
	  if (sizeof($dvids) >= 1 && sizeof($dvids['user']) >= 1) {
	    $all_users = entity_load('user', array_keys($dvids['user']));
	  }
	  $date_start = clone($date_today);
	  $date_start->modify('+2 mondays');
	  $all_gone = TRUE;
	  foreach ($all_users as $this_user) {
	    if (in_array('mediator', $this_user->roles)) {
	  	  $params = array(
		    'name' => $this_user->name,
		    'web_link' => $GLOBALS['base_url'],
		    'week_start_date' => $date_start->format('l, jS M'),
		  );
	  	  $result = drupal_mail('availability', 'weekly_reminder', $this_user->mail, language_default(), $params, 'mediation@mediationbucks.org.uk');
		  if (!$result) $all_gone = FALSE;
	  	}
	  }
      if ($all_gone) {
      	$availability_settings['availability_last_email'] = $date_today->format('Y-m-d H:i:s');
		variable_set("availability_settings", $availability_settings);
	  }
	}
  }
}

// helper function to check whether a user has mediator role
// used in cron
function find_mediator($test_user) {
  if (in_array('mediator', $test_user->roles)) {
  	return true;
  }
  else {
    return false;
  }
}*/

/**
 *  Implements hook_mail to send out reminder email using the user specified template in the admin form.
 *  @params: $params includes the mediator's name, start date for the week and the link to navigate to the site
 */
function availability_mail($key, &$message, $params) {
  $availability_settings= variable_get("availability_settings", array());
  if ($key = 'weekly_reminder') {
  	
	$subject = $availability_settings['availability_email_subject'];
	$subject = str_replace('[week_commencing]', $params['week_start_date'], $subject);
	$subject = str_replace('[site_link]', '<a href=' .$params['web_link'] . '> '. $params['web_link'] . '</a>', $subject);
	
	$body = $availability_settings['availability_email_body'];
	$body = str_replace('[week_commencing]', $params['week_start_date'], $body);
	$body = str_replace('[site_link]', '<a href=' .$params['web_link'] . '> '. $params['web_link'] . '</a>', $body);
	$body_lines = explode('%/', preg_replace('/\r?\n|\r/','%/', $body));
	for ($i = 0 ; $i < sizeof($body_lines) ; $i++) {
	  $body_lines[$i] = '<p> ' . $body_lines[$i] . ' </p>';
	}
    $message['subject'] = $subject;
    $message['body'] = $body_lines;
  }
}

/**
 *  Set up the select box for the exposed filter for the missing updates form.
 *  First set up an associative array of Mondays covered by the report with key full ISO date format
 *  and value abbreviated date.  These are used in descending order to populated the exposed select list control
 *  to choose the week for the report.
 *  
 */
/*function availability_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == "views_exposed_form" && ($form['#id'] == "views-exposed-form-missing-updates-page"  || $form['#id'] == "views-exposed-form-updates-provided-page")) {
    $updates = entity_load('updates');
    $mondays = array();
    if (sizeof($updates) > 0) {
  	  foreach ($updates as $sid => $update) {
	    $date_ob = new DateObject($update->start_date);
	    $mondays[$date_ob->format('Y-m-d H:i:s')] = $date_ob->format('jS F');
      }
    }
    $rmondays = array_reverse($mondays);
    $form['start_date']['#type'] = "select";
    $form['start_date']['#size'] = null;
    $form['start_date']['#options'] = $rmondays;
	if (empty($_GET['start_date']))  {
      $form_state['input']['start_date'] = key($rmondays);
    }
  }
}*/

/**
 *  Implements hook_preprocess_page to attach the table_style.js script to both the the mediator availability 
 *  and availability by mediator pages.
 *  Also sends the array of periods to highlight as affected by a meeting to settings for use by jQuery.
 *  
 */
/*function availability_preprocess_page(&$vars) {
  if($_GET['q'] == 'mediator-availability' || $_GET['q'] == 'availability-by-mediator'){
  	module_load_include('module', 'entity');
    module_load_include('inc', 'meetings');
    module_load_include('inc', 'availability');
	$path = drupal_get_path('module', 'availability');
    drupal_add_js($path . '/scripts/table_style.js');
    
    // Get the meeting highlight array for the mediator_availability view table and pass it to Drupal settings
    $meetings_array = setup_main_table_meetings();
	drupal_add_js(array('availability' => array('meetings' => $meetings_array)), 'setting');
    //Rebuild scripts 
    $scripts = drupal_get_js();
    $vars['scripts'] = $scripts;
  }
}*/

/**
 *  Finds periods affected by a meeting and builds an array ($meetings_array) with an associative array member 
 *  for each affected period containing keyed values for the date of Monday starting the week, the weekday and the period of the day.
 *  
 */
function setup_main_table_meetings() {
  module_load_include('inc', 'availability', 'includes/availability');
  $date_limits = availability_week_limits();
  
  $meetings_array = array();
  // set up the upper and lower limits for weeks displayed by Views
    
  // set up arrays for weekday and period of day values
  $periods = availability_periods_factory();
  
  // Instantiate a MeetingCommitments object and use the checkPeriod method 
  // to return an array of periods in the Views table affected by a meeting
  $meetings = new MeetingCommitments();
  $monday = clone($date_limits['lower']);
  while ($monday <= $date_limits['upper']) {
    foreach ($periods -> availabilityTimes() as $m_t => $m_time) {
      foreach ($periods -> availabilityDays() as $m_d => $m_day) {
        $meetings_list = $meetings->checkPeriod($monday, $m_d, $m_t, false);
		if (sizeof($meetings_list) > 0) {
		  $meetings_array[] = array(
		    'monday' => $monday->format('jS F Y', array('year', 'month', 'day')),
			'day' => $m_d,
			'time' => $m_t
		  );
		}
	  }
	}
	date_modify($monday, "+1 week");
  }
  return $meetings_array;
}

/**
 * Helper function to apply the rules for date ranges and limits in the configuration array to the current date
 * @return: an array with four associative keys: lower, upper, default and delete.  The associated values are date objects  
 * defining the corresponding week.
 * Moved to context class for recording availability but still used in:
 *   availability_block_view
 *   availability_cron
 *   setup_main_table_meetings
 */	 
	
/*function availability_week_limits() {
  $availability_settings= variable_get("availability_settings", array());
  if (sizeof($availability_settings) < 1) {
  	$availability_settings = array (
  	  'lower' => '3',
  	  'delete' => '10',
  	  'default' => '3',
  	  'upper' => '10',
  	);
  }
  $date_today =  new DateObject('now');
  $date_limits['lower'] = clone($date_today);
  date_modify($date_limits['lower'], '+1 Monday');
  do {
    date_modify($date_limits['lower'], '-1 week');
  }  while ($date_limits['lower']->diff($date_today)->format('%R%a') < $availability_settings['availability_start_limit']);
  $date_limits['delete'] = clone($date_limits['lower']);
  do {
  	date_modify($date_limits['delete'], '-1 week');
  } while ($date_limits['delete']->diff($date_today)->format('%R%a') < $availability_settings['availability_delete_week']);
  $date_limits['default'] = clone($date_limits['lower']);
  do {
  	date_modify($date_limits['default'], '+1 week');
	
  } while ($date_today->diff($date_limits['default'])->format('%R%a')  < $availability_settings['availability_default_week']);
  $date_limits['upper'] = clone($date_limits['default']);
  do {
  	date_modify($date_limits['upper'], '+1 week');
  } while ($date_today->diff($date_limits['upper'])->format('%R%a') < $availability_settings['availability_end_limit']);
  return $date_limits;
}*/

/**
* Functions for indirect instantiation of classes
* @return: a new instance of the corresponding class  
*/	 

function meeting_commitments_factory() {
  $meetings = new MeetingCommitments;
  return $meetings;
}

function current_context_factory() {
  $context = new AvailabilityContext();
  return $context;
}

function availability_storage_factory($context) {
  return new AvailabilityStorage($context);
}
